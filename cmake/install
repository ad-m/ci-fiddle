#!/bin/bash
#
# Build docker image.

################################################################################
# Configuration
################################################################################
# Fail on first error
set -e

################################################################################
# Constants
################################################################################
# Get the current working directory, i.e. the directory of this file. All
# credits for this method goes to this guy https://stackoverflow.com/a/246128.
readonly WORKING_DIRECTORY="$(
  cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd
)"

readonly CMAKE_BASE_URL='https://github.com/Kitware/CMake/releases/download'
readonly CMAKE_INSTALL_PATH='/usr/local/cmake'
readonly CMAKE_SYMLINK_PATH='/usr/local/bin'

################################################################################
# Global variables
################################################################################


################################################################################
# Functions
################################################################################
########################################
# Source the versions file to 'include' the CMake version list.
#
# Globals:
#   WORKING_DIRECTORY
# Arguments:
#   None
# Returns:
#   CMAKE_VERSIONS
########################################
cmake::source_versions() {
  local versions_directory="${WORKING_DIRECTORY}/versions"

  . "${versions_directory}"

  if [[ -z ${CMAKE_VERSIONS} ]]; then
    echo "CMAKE_VERSIONS not set"
    exit 1
  fi
}

########################################
# Create install directory for binaries.
#
# Globals:
#   CMAKE_INSTALL_PATH
# Arguments:
#   None
# Returns:
#   None
########################################
cmake::create_install_directory() {
  if [[ ! -d "${CMAKE_INSTALL_PATH}" ]]; then
    mkdir "${CMAKE_INSTALL_PATH}"
  fi
}

########################################
# Download file from URL.
#
# Globals:
#   None
# Arguments:
#   URL URL to download.
# Returns:
#   None
########################################
cmake::download() {
  local url="${1}"
  local destination_path="${2}"

  wget -q "${url}" --directory-prefix ${destination_path}
}
# Saving to: '/linux-cmake/cmake/cmake-3.13.3-Linux-x86_64.tar.gz'
            # /linux-cmake/cmake/cmake-3.13.3-Linux-x86_64/*
########################################
# Unpack archive.
#
# Globals:
#   None
# Arguments:
#   archive_path Path to archive to unpack.
# Returns:
#   None
########################################
cmake::unpack_archive() {
  local archive_path="${1}"
  local destination_path="${2}"

  tar -xz --file "${archive_path}" --directory "${destination_path}"
}

########################################
# Pour contents.
#
# Globals:
#   None
# Arguments:
#   source_path Path to pour the contents from.
#   destination_path Path to pour the contents in.
# Returns:
#   None
########################################
cmake::pour() {
  local source_path="${1}"
  local destination_path="${2}"

  echo "Pouring '${source_path}/*' into '${destination_path}/'"
  if [[ ! -d "${destination_path}" ]]; then
    mkdir "${destination_path}"
  fi

  cp -r "${source_path}"/* "${destination_path}/"
}

########################################
# Pour contents.
#
# Globals:
#   CMAKE_INSTALL_PATH
# Arguments:
#   installed_path ...
#   version Version that the installed binary should be.
# Returns:
#   None
########################################
cmake::verify() {
  local version="${1}"

  installed_version=$(
    "${CMAKE_INSTALL_PATH}/${version}/bin/cmake" --version | \
    grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+'
  )

  if [[ "${installed_version}" != "${version}" ]]; then
    echo "Installed CMake (${installed_version}) doesn't match expected" \
         "version (${version})"
    exit 1
  fi
}

cmake::cleanup() {
  local cleanup_path="${1}"
  rm -r "${cleanup_path}/${archive_filename}"
  rm -r "${cleanup_path}/${filename}"
}

cmake::install() {
  cmake::source_versions
  cmake::create_install_directory

  local tmp_path="$(mktemp)"

  for version in "${CMAKE_VERSIONS[@]}"; do
    # Check if the version is not already installed in CMAKE_INSTALL_PATH

    echo "CMake v${version}"
    filename="cmake-${version}-Linux-x86_64"
    archive_filename="${filename}.tar.gz"
    url="${CMAKE_BASE_URL}/v${version}/${archive_filename}"

    cmake::download "${url}" "${tmp_path}"
    cmake::unpack_archive "${tmp_path}/${archive_filename}" "${tmp_path}"
    cmake::pour "${tmp_path}/${filename}" \
                "${CMAKE_INSTALL_PATH}/${version}"
    cmake::verify "${version}"
    cmake::symlink "${version}"

    cmake::cleanup "${tmp_path}"
  done

  # echo "export CMAKE_BASE_PATH='${CMAKE_BASE_PATH}'" >> ~/.bashrc
  # echo "source /linux-cmake/cmake/versions" >> ~/.bashrc
  # ln -s "${CMAKE_BASE_PATH}/${CMAKE_VERSIONS[0]}/bin/"* /usr/local/bin
}

########################################
# Description.
#
# Globals:
#   CMAKE_INSTALL_PATH
# Arguments:
#   a This is a.
# Returns:
#   None
########################################
cmake::symlink() {
  local version="${1}"
  echo "cmake::symlink ${CMAKE_INSTALL_PATH}/bin/cmake ${CMAKE_SYMLINK_PATH}/cmake-${2}"

  ln -sf "${CMAKE_INSTALL_PATH}/${version}/bin/cmake" \
        "${CMAKE_SYMLINK_PATH}/cmake-${version}"
}


main() {
  echo "main > cmake::install"
  cmake::install "${@}"
  echo "main < cmake::install"
}

echo "main"
main "${@}"
